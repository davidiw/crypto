package abstract

import (
	"crypto/cipher"
	"io"
)

// Cipher defines an interface to an abstract symmetric message cipher.
// The cipher embodies a secret that may be used to encrypt/decrypt data
// as well as to generate cryptographically random bits.
// The Cipher can also cryptographically absorb data or key material,
// updating its state to produce cryptographic hashes and authenticators.
//
// Creating Keyed and Unkeyed Ciphers
//
// The standard function signature for Cipher constructors is:
//
//	NewCipher(key []byte, options ...interface{})
//
// If key is nil, the Cipher constructor picks a fresh, random key.
// The key may be an empty but non-nil slice to create an unkeyed cipher.
// Key material may be of any length, but to ensure full security,
// secret keys should be at least the size returned by the KeySize method.
// The variable-length options argument may contain options
// whose interpretation is specific to the particular cipher.
//
// Message Processing
//
// The main Message method processes a complete message through the Cipher,
// XORing a src byte-slice with cryptographic random bits to yield dst bytes,
// and concurrently absorbing bytes from a key byte-slice into its state:
//
//	cipher.Message(dst, src, key) Cipher
//
// A call always processes exactly max(len(dst),len(dst),len(key)) bytes.
// All slice arguments may be nil or of varying lengths.
// If the src or key slices are short, the missing bytes are taken to be zero.
// If the dst slice is short, the extra output bytes are discarded.
// The src and/or key slices may overlap with dst exactly or not at all.
//
// The Cipher preserves and cryptographically accounts for message boundaries,
// so that the following sequence of two calls yields a result
// that is always cryptographically distinct from the above single call.
//
//	cipher.Message(dst[:div], src[:div], key[:div])
//	cipher.Message(dst[div:], src[div:], key[div:])
//
// The Cipher guarantees that any key material absorbed during a given call
// will cryptographically affect every bit of all future messages processed,
// but makes no guarantees about whether key material absorbed in this call
// will affect some, all, or none of the cryptographic pseudorandom bits
// produced concurrently in the same call.
//
// Authenticated Encryption and Decryption
//
// To encrypt a plaintext msg to produce a ciphertext ctx of the same length,
// and an associated message-authenticator mac, use this sequence of calls:
//
//	cipher.Message(ctx, msg, ctx)	// Encrypt and absorb ciphertext
//	cipher.Message(mac, nil, nil)	// Produce MAC
//
// This encrypts msg into ctx by XORing it with bits generated by the cipher,
// while absorbing the output ciphertext into the cipher's state.
// The second Message call then uses the resulting state to produce a MAC.
//
// This sequence decrypts and verifies a received ciphertext and MAC
// encrypted in the above fashion:
//
//	cipher.Message(msg, ctx, ctx)	// Decrypt and absorb ciphertext
//	cipher.Message(mac, mac, nil)	// Compute MAC and XOR with received
//	valid := subtle.ConstantTimeAllEq(mac, 0)
//
// This decrypts ctx into msg by XORing the same bits used during encryption,
// while similarly absorbing the ciphertext (which is the input this time).
// The second Message call recomputes the MAC based on the absorbed ciphertext,
// XORs the recomputed MAC onto the received MAC in-place,
// and verifies in constant time that the result is zero
// (i.e., that the received and recomputed MACs are equal).
//
// Cryptographic Hashing
//
// This sequence uses a Cipher as a cryptographic hash function taking
// messsage msg and producing cryptographic checksum in slice sum:
//
//	cipher.Message(nil, nil, msg)	// Absorb msg into Cipher state
//	cipher.Message(sum, nil, nil)	// Produce cryptographic hash in sum
//
// Both the input msg and output sum may be of any length,
// and the Cipher guarantees that every bit of the output sum has a
// strong cryptographic dependency on every bit of the input msg.
// However, to achieve full security, the caller should ensure that
// the output sum is at least cipher.HashSize() bytes long.
//
// Streaming Operation
//
// The Partial method processes a partial (initial or continuing) portion
// of a message, allowing the Cipher to be used for byte-granularity streaming:
//
//	cipher.Partial(dst, src, key)
//
// The above single call is thus equivalent to the following pair of calls:
//
//	cipher.Partial(dst[:div], src[:div], key[:div])
//	cipher.Partial(dst[div:], src[div:], key[div:])
//
// One or more calls to Partial must be terminated with a call to Message,
// to complete the message and ensure that key-material bytes absorbed
// in the current message affect the pseudorandom bits the Cipher produces
// in the context of the next message.
// Key material absorbed in a given Partial call may, or may not,
// affect the pseudorandom bits generated in subsequent Partial calls
// if there are no intervening calls to Message.
//
// Stream Cipher or Pseudorandom Bit Generator Operation
//
// A Cipher may be used to generate pseudorandom bits that depend
// only on the Cipher's initial state in the following fashion:
//
//	cipher.Partial(dst, nil, nil)
//
// The standard io.Reader interface may also be used to read pseudorandom bits,
// making the following call equivalent to the one above:
//
//	cipher.Read(dst)
//
// An XOR-based stream cipher equivalent to Go's cipher.Stream interface,
// which XORs pseudorandom bits with src and writes the result into dst,
// may similarly be obtained as follows:
//
//	cipher.Partial(dst, src, nil)
//
// Stream-Oriented Hashing
//
// A Cipher may be used in stream-oriented mode to hash large messages:
//
//	cipher.Partial(nil, nil, buf1)		// absorb message incrementally
//	cipher.Partial(nil, nil, buf2)
//	...
//	cipher.Message(nil, nil, lastBuf)	// finish absorbing message
//	cipher.Partial(sum, nil, nil)		// compute cryptographic sum
//
// The standard io.Writer interface may also be used to absorb input,
// making the following sequence equivalent to the one above:
//
//	cipher.Write(buf1)		// absorb message incrementally
//	cipher.Write(buf2)
//	...
//	cipher.Write(lastBuf)		// absorb last message buffer
//	cipher.Message(nil, nil, nil)	// finish absorbing message
//	cipher.Partial(sum, nil, nil)	// compute cryptographic sum
//
//
type Cipher interface {

	// Transform a message (or the final portion of one) from src to dst,
	// absorb key into the cipher state, and return the Cipher.
	Message(dst, src, key []byte) Cipher

	// Transform a partial, incomplete message from src to dst,
	// absorb key into the cipher state, and return the Cipher.
	Partial(dst, src, key []byte) Cipher

	// Return the minimum size in bytes of secret keys for full security
	// (although key material may be of any size).
	KeySize() int

	// Return recommended size in bytes of hashes for full security.
	// This is usually 2*KeySize() to account for birthday attacks.
	HashSize() int

	// Return the size of block in which this cipher processes data:
	// processing may be slightly more efficient in chunks this size.
	BlockSize() int

	// A Cipher also implements the standard Read and Write I/O methods.
	// Read(dst) is equivalent to Partial(dst, nil).
	// Write(src) is equivalent to Partial(nil, src).
	io.ReadWriter

	// Backwards-compatibility with the Stream cipher interface.
	// XXX this interface inclusion is provisional and may be dropped.
	cipher.Stream

	// Fork off nsubs >= 0 parallel sub-Ciphers and update the state.
	Fork(nsubs int) []Cipher

	// Combine this Cipher's state with that of previously-forked Ciphers.
	// The rejoined sub-Ciphers must no longer be used.
	Join(subs ...Cipher)

	// Create an identical clone of this cryptographic state object.
	// Caution: misuse can lead to key-reuse vulnerabilities.
	Clone() Cipher
}

// CipherMode selects the mode in which a Cipher operates:
// to Encrypt, to Decrypt, or produce a cryptographic random Stream.
//type CipherMode int
//const (
//	Stream  CipherMode = 0  // produce bits without absorbing anything
//	Encrypt CipherMode = 1  // encrypt and absorb output ciphertext
//	Decrypt CipherMode = -1 // decrypt and absorb input ciphertext
//)

// internal type for the simple options above
type option struct{ name string }

func (o *option) String() string { return o.name }

// Pass NoKey to a Cipher constructor to create an unkeyed Cipher.
var NoKey = []byte{}

// Pass RandomKey to a Cipher constructor to create a randomly seeded Cipher.
var RandomKey []byte = nil
